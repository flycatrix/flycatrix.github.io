<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>2018/10第二周读书笔记 | xco1a&#39;s b10g</title>
  <meta name="author" content="xcola">

  
  <meta name="description" content="做有态度的码农">
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="2018/10第二周读书笔记">
  <meta property="og:site_name" content="xco1a&#39;s b10g">

  
  

  
    <meta property="og:image" content="">
  

  
  <link href="/css/images/favicon.ico" rel="icon">
  

  <link rel="alternate" href="/atom.xml" title="xco1a&#39;s b10g" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src="//push.zhanzhang.baidu.com/push.js"></script>

</head>
</html>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">xco1a&#39;s b10g</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-13T04:54:49.000Z"><a href="/2018/10/13/2018-10-第二周读书笔记/">2018-10-13</a></time>
      
      
  
    <h1 class="title">2018/10第二周读书笔记</h1>
  

    </header>
    <div class="entry">
      
        <p>不知不觉断更三个月了。。阿里云外包的工作没有想象中的难适应，多页面vue+jQuery的技术栈，大部分时间都像在写jQuery和原生JS，实现的需求虽然算是过关了，但是觉得代码质量和代码规范还是一团糟。。从一周前每天看几章《JavaScript设计模式与开发实践》，写了点笔记和感想，趁着周末总结出来。</p>
<h2 id="关于面向对象的JavaScript"><a href="#关于面向对象的JavaScript" class="headerlink" title="关于面向对象的JavaScript"></a>关于面向对象的JavaScript</h2><p>传统面向对象语言的几个重要特征，比如继承，封装，多态，在JavaScript动态类型脚本语言中都用迂回的方式实现。比如封装不再依赖private，protected之类的关键字，而是靠函数作用域实现；继承靠原型链实现；多态靠检测参数的值或者给传进来的对象定义一个相同方法名的不同方法。</p>
<h3 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h3><blockquote>
<p>对变量赋值时，不需考虑它的类型 </p>
<p>——可以尝试调用任何对象的任意方法，而不需要考虑它原本是否被设计为拥有该方法</p>
</blockquote>
<p>只关注对象的行为，不去关注对象本身。例如一个对象如果有pop和push方法并且它们有正确的实现，那么就可以当作一个栈来使用（鸭子类型）。</p>
<p>动态类型赋予JavaScript极大的灵活性，也是它能够简化实现各种静态语言设计模式的重要原因。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>同一操作作用于不同的对象上可以产生不同的解释和执行结果。</p>
<p>——把“做什么”和“谁来做”相分离。</p>
<p>1，检测参数，用if分支实现多态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student = &#123;</span><br><span class="line">    say:funtion()&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">'am student'</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> teacher = &#123;</span><br><span class="line">    say:funtion()&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">'am teacher'</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> introduce = <span class="function"><span class="keyword">function</span>(<span class="params">position</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(position === <span class="string">'student'</span>)&#123;            <span class="comment">// 检测传进来的参数值选择采取的操作</span></span><br><span class="line">        student.say()</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(position === <span class="string">'teacher'</span>)&#123;</span><br><span class="line">        teacher.say()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">introduce(<span class="string">'teacher'</span>)  <span class="comment">// am teacher</span></span><br></pre></td></tr></table></figure>
<p>introduce函数通过检测传进来的参数值来执行不同的操作，但如果想再增加一个职位，那么就只能在introduce函数里继续堆砌if语句。</p>
<p>这里可以注意到，student和teacher有同一个方法名的方法say()，虽然他们执行结果不同，但是调用过程是一样的，因此还可以直接把不同的对象传进去，调用同一个方法名的方法实现多态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> introduce = <span class="function"><span class="keyword">function</span>(<span class="params">position</span>)</span>&#123;</span><br><span class="line">    position.say()</span><br><span class="line">&#125;</span><br><span class="line">introduce(student);  <span class="comment">// am student</span></span><br><span class="line">introduce(teacher);  <span class="comment">// am teacher</span></span><br></pre></td></tr></table></figure>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>创建一个对象有两种思路：</p>
<pre><code>a，先指定类型，通过实例化这个类获得一个对象。

b，不关心具体类型，找到一个对象克隆得到一个对象。
</code></pre><p>很明显JavaScript使用第二种思路创建对象。具体的实现过程是那个经典的问题，new操作都干了啥。。</p>
<p>这种创建对象的思路有两个重要的特征，一是<strong>对象能够记住它的原型</strong>，二是<strong>如果对象无法响应一个请求，会委托给自己的原型去处理。</strong></p>
<p>JavaScript的对象最初都是由Object.prototype克隆得到的，所以所有对象最初的原型都指向Object.prototype，但是JavaScript允许对象动态的改变对象原型的指向，因此才有各种灵活的继承实现。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>保证一个类仅有一个实例，并提供一个访问这个实例的全局访问点。</p>
<p>思路：用一个变量标识这个类有没有创建过对象，如果创建过则直接返回之前创建的对象，否则创建一个实例并返回。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>普通实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">null</span>;                <span class="comment">// 是否创建过对象的标识</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;                <span class="comment">// 访问点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>缺点：使用者必须用Singleton.getInstance创建单例，而不能直接使用new Singleton()的方式。</p>
<p>透明实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Singleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;                     <span class="comment">// 是否创建过对象的标识</span></span><br><span class="line">    <span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance)&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = props;</span><br><span class="line">        <span class="keyword">this</span>.init();				 <span class="comment">// 为单例执行某些操作</span></span><br><span class="line">        <span class="keyword">return</span> instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Singleton.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	<span class="comment">// some code...</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> Singleton;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Singleton(<span class="string">'xcola'</span>)</span><br><span class="line">a   <span class="comment">// Singleton &#123;name: "xcola"&#125;</span></span><br></pre></td></tr></table></figure>
<p>缺点：违反单一职责原则，代码复杂。</p>
<p>代理实现：将管理单一实例的代码和创建实例的代码相拆分，使得创建不同的对象也可以使用单例模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateObj = <span class="function"><span class="keyword">function</span>(<span class="params">props</span>)</span>&#123;			<span class="comment">// 创建单例</span></span><br><span class="line">    <span class="keyword">this</span>.name = props;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line">CreateObj.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;       <span class="comment">// 执行构建单例的操作</span></span><br><span class="line">	<span class="comment">// some code...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> proxyCreateObj = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;			<span class="comment">// 代理实现控制单一实例</span></span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> CreateObj(props);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">var</span> a = proxyCreateObj(<span class="string">'emm'</span>)</span><br><span class="line">a     <span class="comment">// CreateObj &#123;name: "emm"&#125;</span></span><br></pre></td></tr></table></figure>
<p>BB了这么多，JavaScript最简单的单例实现是创建全局变量。/笑哭</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>:<span class="string">'emm'</span>&#125;</span><br><span class="line"><span class="comment">//首先它独一无二，其次它能全局都访问到</span></span><br></pre></td></tr></table></figure>
<p>大量使用全局变量总是不好的，引入命名空间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> namespace = &#123;</span><br><span class="line">    a:&#123;&#125;,</span><br><span class="line">    b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于惰性单例"><a href="#关于惰性单例" class="headerlink" title="关于惰性单例"></a>关于惰性单例</h3><p>在需要的时候才创建单例实例（事件触发）。将创建实例的职责和管理单例的职责写在两个方法里，他们相互之间可以独立变化而互不影响，结合在一起使用就完成了一个单例模式。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>定义一系列的算法，把他们封装起来，使他们可以相互替换。</p>
<p>思路：一个基于策略模式的程序由至少两部分组成，一组<strong>策略类，存放具体的算法</strong>，一组<strong>环境类，接受客户的请求，委托给某一个策略类处理。</strong></p>
<p>做法：告诉程序，谁来做，做什么。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strategies = &#123;					<span class="comment">// 一组策略类</span></span><br><span class="line">    <span class="string">"s"</span>:<span class="function"><span class="keyword">function</span>(<span class="params">salary</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary*<span class="number">4</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"a"</span>:<span class="function"><span class="keyword">function</span>(<span class="params">salary</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary*<span class="number">3</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">	<span class="string">"b"</span>:<span class="function"><span class="keyword">function</span>(<span class="params">salary</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> caculate = <span class="function"><span class="keyword">function</span>(<span class="params">level,salary</span>)</span>&#123;	<span class="comment">// 选取策略类，执行对应操作</span></span><br><span class="line">    <span class="keyword">return</span> strategies[level](salary);</span><br><span class="line">&#125;</span><br><span class="line">caculate(<span class="string">'s'</span>,<span class="number">1000</span>)      <span class="comment">// 4000</span></span><br></pre></td></tr></table></figure>
<p>应用场景：某个元素的不同动态效果，不断变更的表单验证方式</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>为一个对象提供一个代用品或者占位符，以便控制对它的访问。</p>
<p>思路：当不方便直接访问一个对象或者当前不满足条件的时候，提供一个替身对象来控制这个对象。</p>
<h3 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h3><p>创建代理舰艇某个对象的状态变化，在合适的时机由代理对象执行操作。</p>
<p>example：在图片尚未加载完成时显示loading.gif图。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newImg = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(imgNode);</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        setSrc:<span class="function"><span class="keyword">function</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">            imgNode.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">var</span> proxySetImg = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image;</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        newImg.setSrc(<span class="keyword">this</span>.src);            <span class="comment">// 3，加载完毕时将img节点的loading图替换成真正的图片</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        setSrc:<span class="function"><span class="keyword">function</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">            newImg.setSrc(<span class="string">'loading.gif'</span>);   <span class="comment">// 2，先显示loading图</span></span><br><span class="line">            img.src = src                   <span class="comment">// 1，接受真正的图片地址</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">proxySetImg.setSrc(<span class="string">'http://imgurl'</span>)</span><br></pre></td></tr></table></figure>
<p>代理对象和被代理对象都提供setSrc方法，所以任何使用本体对象的场景都可以无缝切换成代理对象。</p>
<p>应用场景：合并http请求，惰性加载文件。</p>
<h3 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h3><p>为一些开销大的运算缓存结果，下次运算时如果参数一致，直接从缓存池中返回之前计算的结果。</p>
<p>example：缓存乘积运算</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mult = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++)&#123;</span><br><span class="line">        result = result * <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> proxyMult = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>,<span class="string">','</span>);</span><br><span class="line">        <span class="keyword">if</span>(args <span class="keyword">in</span> cache)&#123;</span><br><span class="line">            <span class="keyword">return</span> cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[args] = mult.apply(<span class="keyword">this</span>.arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">proxyMult(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)     <span class="comment">// 6 mult函数计算得出</span></span><br><span class="line">proxyMult(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)     <span class="comment">// 6 proxyMult从缓存中取出之前的结果</span></span><br></pre></td></tr></table></figure>
<h2 id="发布-订阅（观察者）模式"><a href="#发布-订阅（观察者）模式" class="headerlink" title="发布-订阅（观察者）模式"></a>发布-订阅（观察者）模式</h2><p>定义对象间一种一对多的依赖关系，当一个对象（发布者）的状态发生改变时，所有依赖于它的对象（订阅者）都将得到通知。在js中事件模型即是。</p>
<p>思路：1，指定发布者。2，为发布者添加缓存列表，存放订阅者的回调。3，发布消息时遍历缓存列表。</p>
<h3 id="简单订阅-发布实现："><a href="#简单订阅-发布实现：" class="headerlink" title="简单订阅-发布实现："></a>简单订阅-发布实现：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> publisher = &#123;&#125;;						<span class="comment">// 定义发布者</span></span><br><span class="line">publisher.clientList = [];				 <span class="comment">// 定义缓存池</span></span><br><span class="line">publisher.listen = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;    <span class="comment">// 订阅方法</span></span><br><span class="line">    <span class="keyword">this</span>.clientList.push(callback);</span><br><span class="line">&#125;</span><br><span class="line">publisher.trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;			  <span class="comment">// 发布消息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>,fn; fn = <span class="keyword">this</span>.clientList[i++]; )&#123;</span><br><span class="line">        fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> subscriber = &#123;							<span class="comment">// 定义订阅者</span></span><br><span class="line">    name:<span class="string">'xcola'</span>,</span><br><span class="line">    subscribe:<span class="function"><span class="keyword">function</span>(<span class="params">info</span>)</span>&#123;				 <span class="comment">// 订阅的回调</span></span><br><span class="line">        <span class="built_in">console</span>.log(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">publisher.listen(subscriber.subscribe);		  <span class="comment">// 将订阅者的回调传给listen函数，加入发布者的缓存池中</span></span><br><span class="line">publisher.trigger(<span class="string">'emmm'</span>)                     <span class="comment">// subscriber.subscribe输出“emmm”</span></span><br></pre></td></tr></table></figure>
<p>在此种实现下，订阅者会收到所有发布者的消息，若添加一个标识，指定订阅哪种类型的消息，这样就不会给订阅者带来不必要的困扰。</p>
<h3 id="指定订阅类型"><a href="#指定订阅类型" class="headerlink" title="指定订阅类型"></a>指定订阅类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">publisher.listen = <span class="function"><span class="keyword">function</span>(<span class="params">key,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.clientList[key])&#123;			<span class="comment">// 如果先前不存在这种标识的发布类型则新建一个</span></span><br><span class="line">        <span class="keyword">this</span>.clientList[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.clientList[key].push(callback);	<span class="comment">// 将回调存进对应key标识的缓存池中</span></span><br><span class="line">&#125;</span><br><span class="line">publisher.trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>),  <span class="comment">// 取出arguments中第一个参数，即key</span></span><br><span class="line">        fns = <span class="keyword">this</span>.clientList[key];		 <span class="comment">// 取出对应key的缓存池</span></span><br><span class="line">    <span class="keyword">if</span>(!fns || fns.length === <span class="number">0</span>)&#123;			<span class="comment">// 如果没有回调返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>,fn; fn = <span class="keyword">this</span>.clientList[i++]; )&#123;</span><br><span class="line">        fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>)		<span class="comment">// 遍历缓存池，调用回调函数传递消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">publisher.listen(<span class="string">'xcola'</span>,subscriber.subscribe);</span><br><span class="line">publisher.trigger(<span class="string">'xcola'</span>,<span class="string">'emmm'</span>)              <span class="comment">// 只有标识为xcola的回调会收到emmm</span></span><br></pre></td></tr></table></figure>
<h3 id="添加取消订阅功能"><a href="#添加取消订阅功能" class="headerlink" title="添加取消订阅功能"></a>添加取消订阅功能</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">publiser.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fns = <span class="keyword">this</span>.clientList[key];        <span class="comment">// 取出对应key的缓存池</span></span><br><span class="line">    <span class="keyword">if</span>(!fns)&#123;                             <span class="comment">// 如果缓存池不存在，则返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!callback)&#123;					<span class="comment">// 如果没有指定对应key的callback，则清除对应key的所有订阅回调</span></span><br><span class="line">        fns &amp;&amp; (fns.length === <span class="number">0</span>);		<span class="comment">// 只有fns不为空才会执行fns.length === 0</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = fns.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">var</span> _callback = fns[i];</span><br><span class="line">            <span class="keyword">if</span>(_callback == callback)&#123;</span><br><span class="line">                fns.splice(i,<span class="number">1</span>);		<span class="comment">// 删除缓存池中找到的对应的订阅callback</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="给对象动态的添加订阅发布功能"><a href="#给对象动态的添加订阅发布功能" class="headerlink" title="给对象动态的添加订阅发布功能"></a>给对象动态的添加订阅发布功能</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = &#123;                        <span class="comment">// 将所有方法封装在一个对象中</span></span><br><span class="line">    clientLish:[],</span><br><span class="line">    listen:<span class="function"><span class="keyword">function</span>(<span class="params">key,callback</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="keyword">this</span>.clientList[key])&#123;</span><br><span class="line">                    <span class="keyword">this</span>.clientList[key] = []</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.clientList[key].push(callback);</span><br><span class="line">            &#125;,</span><br><span class="line">    trigger:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>),</span><br><span class="line">                    fns = <span class="keyword">this</span>.clientList[key];</span><br><span class="line">                <span class="keyword">if</span>(!fns || fns.length === <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>,fn; fn = <span class="keyword">this</span>.clientList[i++]; )&#123;</span><br><span class="line">                    fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">    remove:<span class="function"><span class="keyword">function</span>(<span class="params">key,callback</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> fns = <span class="keyword">this</span>.clientList[key];</span><br><span class="line">            <span class="keyword">if</span>(!fns)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!callback)&#123;</span><br><span class="line">                fns &amp;&amp; (fns.length === <span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">let</span> i = fns.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">                    <span class="keyword">var</span> _callback = fns[i];</span><br><span class="line">                    <span class="keyword">if</span>(_callback == callback)&#123;</span><br><span class="line">                        fns.splice(i,<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> installEvent = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;			<span class="comment">// 为某个对象安装订阅发布功能</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> event)&#123;					<span class="comment">// 遍历event的方法，为传入的对象添加event中存放的方法</span></span><br><span class="line">        obj[i] = event[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                                                                        于2018/10/14 夜</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="javascript:void(0)" class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/前端/">前端</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/学习笔记/">学习笔记</a>, <a href="/tags/JavaScript设计模式与开发实践/">JavaScript设计模式与开发实践</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Categories</h3>
  <ul class="entry">
  
    <li><a href="/categories/前端/">前端</a><small>17</small></li>
  
    <li><a href="/categories/博客/">博客</a><small>1</small></li>
  
    <li><a href="/categories/服务器/">服务器</a><small>2</small></li>
  
    <li><a href="/categories/随笔/">随笔</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2018/12/22/一点感想/">一点感想</a>
      </li>
    
      <li>
        <a href="/2018/12/18/前端导出数据到excel文件/">前端导出数据到excel文件</a>
      </li>
    
      <li>
        <a href="/2018/12/18/LeeTCode两数相加/">LeeTCode两数相加</a>
      </li>
    
      <li>
        <a href="/2018/11/17/2018-11-杂记/">2018-11-杂记</a>
      </li>
    
      <li>
        <a href="/2018/10/27/2018-10-第四周读书笔记/">2018/10第四周杂记</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/JavaScript设计模式与开发实践/">JavaScript设计模式与开发实践</a><small>2</small></li>
  
    <li><a href="/tags/NodeJS/">NodeJS</a><small>1</small></li>
  
    <li><a href="/tags/React/">React</a><small>1</small></li>
  
    <li><a href="/tags/Vue/">Vue</a><small>1</small></li>
  
    <li><a href="/tags/jQuery/">jQuery</a><small>1</small></li>
  
    <li><a href="/tags/代码整洁之道/">代码整洁之道</a><small>1</small></li>
  
    <li><a href="/tags/学习笔记/">学习笔记</a><small>15</small></li>
  
    <li><a href="/tags/瞎折腾/">瞎折腾</a><small>3</small></li>
  
    <li><a href="/tags/随笔/">随笔</a><small>1</small></li>
  
    <li><a href="/tags/面试笔记/">面试笔记</a><small>2</small></li>
  
    <li><a href="/tags/首刷javascript高级程序设计/">首刷javascript高级程序设计</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/JavaScript设计模式与开发实践/" style="font-size: 13.33px;">JavaScript设计模式与开发实践</a> <a href="/tags/NodeJS/" style="font-size: 10px;">NodeJS</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/jQuery/" style="font-size: 10px;">jQuery</a> <a href="/tags/代码整洁之道/" style="font-size: 10px;">代码整洁之道</a> <a href="/tags/学习笔记/" style="font-size: 20px;">学习笔记</a> <a href="/tags/瞎折腾/" style="font-size: 16.67px;">瞎折腾</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a> <a href="/tags/面试笔记/" style="font-size: 13.33px;">面试笔记</a> <a href="/tags/首刷javascript高级程序设计/" style="font-size: 13.33px;">首刷javascript高级程序设计</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2018 xcola
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id="bg"></div>
</body>
</html>